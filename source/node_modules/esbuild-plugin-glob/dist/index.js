'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var chokidar = require('chokidar');
var esbuild = require('esbuild');
var fs = require('fs');
var match = require('minimatch');
var path = require('path');
var glob = require('tiny-glob');
var invariant = require('tiny-invariant');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var chokidar__default = /*#__PURE__*/_interopDefaultLegacy(chokidar);
var esbuild__namespace = /*#__PURE__*/_interopNamespace(esbuild);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var match__default = /*#__PURE__*/_interopDefaultLegacy(match);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var glob__default = /*#__PURE__*/_interopDefaultLegacy(glob);
var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

function globPlugin({
  chokidarOptions,
  controls,
  silent = false,
  additionalEntrypoints = []
} = {}) {
  const log = createLogger(silent);
  const context = {
    watcher: void 0
  };
  const controlFunctions = {
    async stopWatching() {
      if (!context.watcher)
        return;
      await context.watcher.close();
    }
  };
  const plugin = {
    name: "glob",
    async setup(build) {
      if (!Array.isArray(build.initialOptions.entryPoints) || !Array.isArray(additionalEntrypoints)) {
        throw new TypeError("GlobPlugin currently only supports array entrypoints");
      }
      if (build.initialOptions.watch) {
        const entryGlobs = [...build.initialOptions.entryPoints, ...additionalEntrypoints];
        const watcher = chokidar__default["default"].watch(entryGlobs, chokidarOptions);
        context.watcher = watcher;
        build.initialOptions.entryPoints = void 0;
        const onRebuild = typeof build.initialOptions.watch === "object" ? build.initialOptions.watch.onRebuild : void 0;
        build.initialOptions.watch = false;
        const sharedOptions = {
          ...build.initialOptions,
          incremental: true,
          metafile: true
        };
        const entryToInputsMap = /* @__PURE__ */ new Map();
        const entryToBuildResultMap = /* @__PURE__ */ new Map();
        const entryToOutputsMap = /* @__PURE__ */ new Map();
        const matchesGlobs = (filePath) => {
          return entryGlobs.some((glob2) => match__default["default"](filePath, glob2));
        };
        const handleBuildResult = async (entry, buildResult) => {
          invariant__default["default"](watcher);
          invariant__default["default"](buildResult.metafile, "Expected metafile to be created");
          const outputs = Object.keys(buildResult.metafile.outputs);
          const inputs = Object.values(buildResult.metafile.outputs).filter((output) => !!output.entryPoint).flatMap((output) => Object.keys(output.inputs).filter((input) => !input.includes("node_modules")).map((input) => normalizePath(input)));
          watcher.add(inputs);
          entryToInputsMap.set(entry, inputs);
          entryToOutputsMap.set(entry, outputs);
          entryToBuildResultMap.set(entry, buildResult);
          onRebuild == null ? void 0 : onRebuild(null, buildResult);
        };
        const findEntriesByInput = (input) => {
          return [...entryToInputsMap.entries()].filter(([_entry, inputs]) => inputs.includes(input)).map(([entry]) => entry);
        };
        watcher.on("add", async (addedPath) => {
          if (!matchesGlobs(addedPath))
            return;
          log("[add]", addedPath);
          const buildResult = await esbuild__namespace.build({
            ...sharedOptions,
            entryPoints: [addedPath]
          });
          handleBuildResult(addedPath, buildResult);
        }).on("change", async (changedPath) => {
          const entries = findEntriesByInput(changedPath);
          entries.forEach(async (entry) => {
            log("[change]", entry);
            const oldResult = entryToBuildResultMap.get(entry);
            try {
              invariant__default["default"](oldResult == null ? void 0 : oldResult.rebuild, "Expected all build results to be incremental");
              handleBuildResult(entry, await oldResult.rebuild());
            } catch {
            }
          });
        }).on("unlink", async (unlinkedPath) => {
          if (build.initialOptions.write === false)
            return;
          const outputPaths = entryToOutputsMap.get(unlinkedPath);
          if (outputPaths) {
            log("[unlink]", unlinkedPath);
            outputPaths.forEach((outputPath) => fs__default["default"].unlinkSync(outputPath));
          }
        });
      } else {
        const entryGlobs = [...build.initialOptions.entryPoints, ...additionalEntrypoints];
        const resolvedEntryPoints = await Promise.all(entryGlobs.map((entryPoint) => glob__default["default"](entryPoint))).then((nestedEntryPoints) => nestedEntryPoints.flat());
        build.initialOptions.entryPoints = resolvedEntryPoints;
      }
    }
  };
  return controls ? [plugin, controlFunctions] : plugin;
}
function createLogger(silent) {
  return (...arguments_) => {
    if (!silent)
      console.log(...arguments_);
  };
}
function normalizePath(filePath) {
  return path__default["default"].relative(process.cwd(), filePath.replace(/^(\w+:)/, ""));
}

exports.globPlugin = globPlugin;
//# sourceMappingURL=index.js.map
